NEXT STEPS:

4) Implement serialization and deserialization of CodeObject
5) VM in C


VM instructions
===============

The following are instructions in their original form, before being assembled
to actual bytecode.

SP - stack pointer
TOS - value at top of stack


Opcode              Args        Description
------              ----        -----------

CONST               val         Push constant value to stack

LOADVAR             sym         Push var value to stack

STOREVAR            sym         Place TOS in var and pop stack

DEFVAR              sym         Define var to be the value in TOS and pop stack

FUNCTION            fn          Make closure from fn and current env, and push
                                it onto stack.

POP                             Pop value from stack

FJUMP               label       Jump if TOS is false to label and pop stack

JUMP                label       Jump to label

RETURN                          Return from function to last return point

CALL                n           Call function that's in TOS, saving
                                return point. n - number of arguments passed.



Bytecode
========

Each instruction is coded into a 4-byte word. First byte encodes the instruction
and the other 3 its argument(s).

Bytecode has to be serializable into a binary file that can be loaded by a VM
written in other languages (and later, by the same VM - to separate the
compilation stage from VM interpretation)


RANDOM THOUGHTS
===============

(*) I think I'll leave internal definitions be. R5RS allows internal definitions
    only in the beginning of blocks anyway. Doing the scanning out and convertion
    to letrec will just convolute the resulting bytecode with another layer of 
    'lambda'. This is tangential to my goals with Bob.
 
